name: Pipelines Execute
run-name: Run Gruntwork Pipelines
on:
  workflow_call:
    secrets:
      GRUNTWORK_CODE_ACCESS_TOKEN:
        required: true

env:
  DEPLOY_BRANCH_NAME: main
  GRUNTWORK_INSTALLER_VERSION: v0.0.39
  MODULE_SECURITY_VERSION: v0.68.3
  CONTROL_TOWER_MODULES_VERSION: v0.4.2
  BOILERPLATE_VERSION: v0.5.8

jobs:
  preflight_checks:
    name: Run config preflight checks for gruntwork pipelines
    runs-on: ubuntu-latest
    env:
      GRUNTWORK_CODE_ACCESS_TOKEN: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
    steps:
      - name: Update comment
        uses: gruntwork-io/pipelines-status-update@v0.1.0
        with:
          step_name: "Preflight Checks"
          step_status: "in_progress"

      - name: Ensure CI User Variables are populated
        shell: bash
        run: |
          if [[ -z "$GRUNTWORK_CODE_ACCESS_TOKEN" ]]; then echo "Missing GRUNTWORK_CODE_ACCESS_TOKEN"; exit 1; fi
      # See https://stackoverflow.com/a/76151412
      - uses: actions/checkout@v4
        # Only run if this is a pull request and the target branch is main
        if: ${{ github.event_name == 'pull_request' && github.event.pull_request.base.ref == 'main' }}
        with:
          fetch-depth: 0
      - name: Check if branch is ahead of main
        # Only run if this is a pull request and the target branch is main
        if: ${{ github.event_name == 'pull_request' && github.event.pull_request.base.ref == 'main' }}
        env:
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          if ! git merge-base --is-ancestor origin/main "$HEAD_SHA"; then
            echo "::error::Branch is not up to date with main"
            exit 1
          fi
      - name: Update comment
        uses: gruntwork-io/pipelines-status-update@v0.1.0
        with:
          step_name: "Preflight Checks"
          step_status: "success"
          step_details: "Validated envvars and git branch status"

  detect_changes:
    name: Detect Infrastructure Changes
    runs-on: ubuntu-latest
    needs: [preflight_checks]
    steps:
      - name: Update comment
        uses: gruntwork-io/pipelines-status-update@v0.1.0
        with:
          step_name: "Calculate Infrastructure Changes"
          step_status: "in_progress"
      - uses: actions/checkout@v4
        with:
          # Fetch all history
          fetch-depth: 0

      - name: Read Gruntwork config file
        id: gruntwork
        shell: bash
        run: |
          config="$(cat .gruntwork/config.yml | base64 -w 0)"
          echo "config=$config" >> $GITHUB_OUTPUT
          pipelines_cli_version="$(yq -r .pipelines.cli-version .gruntwork/config.yml)"
          echo "pipelines_cli_version=$pipelines_cli_version" >> $GITHUB_OUTPUT

      - name: Set custom ref variables
        id: ref
        # If this run was triggered manually, we'll use the source and target ref from the user input. Otherwise, we'll
        # use our default approach.
        # pull requests need to use pull_request.head.sha, rather than HEAD, because by default HEAD for PRs is a merge commit that isn't in the actual history
        run: |
          echo "source_ref=${{ inputs.source_ref || '$(./.github/scripts/source-ref.sh)'}}" >> $GITHUB_OUTPUT

          if [[ '${{  github.event_name }}' = 'pull_request' ]]; then
            echo "branch_ref=${{ inputs.target_ref || github.event.pull_request.head.sha }}" >> $GITHUB_OUTPUT
          else
            echo "branch_ref=${{ inputs.target_ref || '$(git rev-parse HEAD)'}}" >> $GITHUB_OUTPUT
          fi
        shell: bash

      - name: Get event-type
        id: event_type
        run: |
          if [[ "${GITHUB_REF##*/}" == "main" ]]; then
              echo "event_type=push" >> $GITHUB_OUTPUT
          else
              echo "event_type=pr-synched-created" >> $GITHUB_OUTPUT
          fi

      - name: Pipelines Orchestrate
        id: orchestrate
        uses: gruntwork-io/pipelines-orchestrate@v1.1.0
        with:
          repository-path: "."
          repository-url: ${{ github.server_url }}/${{ github.repository }}
          source-ref: ${{ steps.ref.outputs.source_ref }}
          target-ref: ${{ steps.ref.outputs.branch_ref }}
          event-type: ${{ steps.event_type.outputs.event_type }}
          gruntwork-config: ${{ steps.gruntwork.outputs.config }}
          # We do this because the `GRUNTWORK_CODE_ACCESS_TOKEN` might not be present when vending a delegated account, even though it's always present in the main `infrastructure-live` account.
          token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
      - name: Update comment
        uses: gruntwork-io/pipelines-status-update@v0.1.0
        with:
          step_name: "Calculate Infrastructure Changes"
          step_status: "success"
          step_details: ${{ steps.orchestrate.outputs.jobs }}
    outputs:
      pipelines_jobs: ${{ steps.orchestrate.outputs.jobs }}
      pipelines_cli_version: ${{ steps.gruntwork.outputs.pipelines_cli_version }}

  pipelines_determine:
    name: ${{ matrix.jobs.ChangeType }} - ${{ matrix.jobs.WorkingDirectory }}
    needs: [detect_changes]
    runs-on: ubuntu-latest
    # GHA can't check for length, so we just check if there is an item in the 0 index
    if: fromJson(needs.detect_changes.outputs.pipelines_jobs)[0] != null
    strategy:
      fail-fast: false
      max-parallel: 3
      matrix:
        jobs: ${{ fromJson(needs.detect_changes.outputs.pipelines_jobs) }}
    steps:
      - name: Check out repo code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Update comment
        uses: gruntwork-io/pipelines-status-update@v0.1.0
        with:
          step_name: ${{ matrix.jobs.ChangeType }} - ${{ matrix.jobs.WorkingDirectory }}
          step_status: "in_progress"

      - name: Bootstrap Workflow
        id: bootstrap
        uses: gruntwork-io-team/pipelines-bootstrap@main
        with:
          token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
          change_type: ${{ matrix.jobs.ChangeType }}
          branch: ${{ matrix.jobs.Ref }}
          working_directory: ${{ matrix.jobs.WorkingDirectory }}
          account_id: ${{ matrix.jobs.AccountId }}
          terragrunt_command: ${{ matrix.jobs.Action.Command }} ${{ matrix.jobs.Action.Args }}
          additional_data: ${{ toJson(matrix.jobs.AdditionalData) }}
          child_account_id: ${{ matrix.jobs.AdditionalData.ChildAccountId }}
          new_account_name: ${{ matrix.jobs.AdditionalData.AccountName }}
          team_account_names: ${{ matrix.jobs.AdditionalData.TeamAccountNames }}

      - name: "[Baseline]: Authenticate to Security AWS account"
        if: steps.bootstrap.outputs.workflow == 'apply-new-account-baseline.yml'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: us-east-1
          role-to-assume: "arn:aws:iam::${{ steps.bootstrap.outputs.security_account_id }}:role/${{ steps.bootstrap.outputs.role_name }}"
          role-duration-seconds: 3600
          role-session-name: ${{ steps.bootstrap.outputs.role_session_name }}

      - name: "[Baseline]: Run terragrunt ${{ steps.bootstrap.outputs.terragrunt_command }} in security account"
        id: terragrunt-apply-security
        if: steps.bootstrap.outputs.workflow == 'apply-new-account-baseline.yml'
        uses: gruntwork-io/pipelines-execute@v3.0.0
        with:
          token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
          tf_version: ${{ steps.bootstrap.outputs.terraform_version }}
          tg_version: ${{ steps.bootstrap.outputs.terragrunt_version }}
          pipelines_cli_version: ${{ steps.bootstrap.outputs.pipelines_cli_version }}
          working_directory: security/_global/account-baseline
          terragrunt_command: "${{ steps.bootstrap.outputs.terragrunt_command }}"
          infra_live_repo: '.'
          infra_live_directory: '.'
          infra_live_repo_branch: ${{ steps.bootstrap.outputs.branch }}
          gruntwork_config: "${{ steps.bootstrap.outputs.gruntwork_config }}"

      - name: "[Baseline]: Authenticate to Logs AWS account"
        if: steps.bootstrap.outputs.workflow == 'apply-new-account-baseline.yml'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: us-east-1
          role-to-assume: "arn:aws:iam::${{ steps.bootstrap.outputs.logs_account_id }}:role/${{ steps.bootstrap.outputs.role_name }}"
          role-duration-seconds: 3600
          role-session-name: ${{ steps.bootstrap.outputs.role_session_name }}

      - name: "[Baseline]: Run terragrunt ${{ steps.bootstrap.outputs.terragrunt_command }} in logs account"
        id: terragrunt-apply-logs
        if: steps.bootstrap.outputs.workflow == 'apply-new-account-baseline.yml'
        uses: gruntwork-io/pipelines-execute@v3.0.0
        with:
          token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
          tf_version: ${{ steps.bootstrap.outputs.terraform_version }}
          tg_version: ${{ steps.bootstrap.outputs.terragrunt_version }}
          pipelines_cli_version: ${{ steps.bootstrap.outputs.pipelines_cli_version }}
          working_directory: logs/_global/account-baseline
          terragrunt_command: "${{ steps.bootstrap.outputs.terragrunt_command }}"
          infra_live_repo: '.'
          infra_live_directory: '.'
          infra_live_repo_branch: ${{ steps.bootstrap.outputs.branch }}
          gruntwork_config: "${{ steps.bootstrap.outputs.gruntwork_config }}"

      - name: "[Baseline]: Authenticate to Shared Services AWS account"
        if: steps.bootstrap.outputs.workflow == 'apply-new-account-baseline.yml'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: us-east-1
          role-to-assume: "arn:aws:iam::${{ steps.bootstrap.outputs.shared_account_id }}:role/${{ steps.bootstrap.outputs.role_name }}"
          role-duration-seconds: 3600
          role-session-name: ${{ steps.bootstrap.outputs.role_session_name }}

      - name: "[Baseline]: Run terragrunt ${{ steps.bootstrap.outputs.terragrunt_command }} in shared account"
        id: terragrunt-apply-shared
        if: steps.bootstrap.outputs.workflow == 'apply-new-account-baseline.yml'
        uses: gruntwork-io/pipelines-execute@v3.0.0
        with:
          token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
          tf_version: ${{ steps.bootstrap.outputs.terraform_version }}
          tg_version: ${{ steps.bootstrap.outputs.terragrunt_version }}
          pipelines_cli_version: ${{ steps.bootstrap.outputs.pipelines_cli_version }}
          working_directory: shared/_global/account-baseline
          terragrunt_command: "${{ steps.bootstrap.outputs.terragrunt_command }}"
          infra_live_repo: '.'
          infra_live_directory: '.'
          infra_live_repo_branch: ${{ steps.bootstrap.outputs.branch }}
          gruntwork_config: "${{ steps.bootstrap.outputs.gruntwork_config }}"

      # Finally, auth to the mgmt account so we can assume a role in the child account
      - name: "[Baseline]: Authenticate to AWS"
        if: steps.bootstrap.outputs.workflow == 'apply-new-account-baseline.yml'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: us-east-1
          role-to-assume: "arn:aws:iam::${{ steps.bootstrap.outputs.account_id }}:role/${{ steps.bootstrap.outputs.role_name }}"
          role-duration-seconds: 3600
          role-session-name: ${{ steps.bootstrap.outputs.role_session_name }}

      # Auth to child account
      # THIS RETRIEVES PERMISSIONS TO BE ABLE TO RUN A PLAN/APPLY IN THE NEWLY CREATED CHILD ACCOUNT
      # The "AWSControlTowerExecution" role being assumed here is created by Control Tower in each account it provisions
      # and it can be assumed by a role in the management account.
      - name: "[Baseline]: Assume role new child account"
        if: steps.bootstrap.outputs.workflow == 'apply-new-account-baseline.yml'
        env:
          SESSION_NAME: ${{ steps.bootstrap.outputs.role_session_name }}
          CHILD_ACCOUNT: ${{ steps.bootstrap.outputs.child_account_id }}
        run: |
          RESPONSE="$(aws sts assume-role --role-arn "arn:aws:iam::$CHILD_ACCOUNT:role/AWSControlTowerExecution" --role-session-name "$SESSION_NAME")"
          ASSUMED_ROLE_CREDS="$(echo "$RESPONSE" | jq -r '.Credentials')"
          AWS_ACCESS_KEY_ID="$(echo "$ASSUMED_ROLE_CREDS" | jq -r '.AccessKeyId')"
          echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID" >> "$GITHUB_ENV"
          echo "::add-mask::$AWS_ACCESS_KEY_ID"
          AWS_SECRET_ACCESS_KEY="$(echo "$ASSUMED_ROLE_CREDS" | jq -r '.SecretAccessKey')"
          echo AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY" >> "$GITHUB_ENV"
          echo "::add-mask::$AWS_SECRET_ACCESS_KEY"
          AWS_SESSION_TOKEN="$(echo "$ASSUMED_ROLE_CREDS" | jq -r '.SessionToken')"
          echo AWS_SESSION_TOKEN="$AWS_SESSION_TOKEN" >> "$GITHUB_ENV"
          echo "::add-mask::$AWS_SESSION_TOKEN"

      - name: "[Baseline]: Confirm Account Access"
        if: steps.bootstrap.outputs.workflow == 'apply-new-account-baseline.yml'
        env:
          CHILD_ACCOUNT: ${{ steps.bootstrap.outputs.child_account_id }}
          WORKING_DIRECTORY: ${{ steps.bootstrap.outputs.working_directory }}
        run: echo "::notice ::Running in account $CHILD_ACCOUNT and planning in $WORKING_DIRECTORY"

      # This Bootstrap step is a workaround for the error that happens when running plan-all for the first time in a
      # new account with multiple modules. The error is:
      #
      #    OperationAborted: A conflicting conditional operation is currently in progress against this resource. Please try again.
      #    BucketAlreadyOwnedByYou: Your previous request to create the named bucket succeeded and you already own it.
      #
      # This happens because each module is trying to create buckets for state and logs when they do not exist.
      # Setting Terragrunt Parallelism to 1 does NOT prevent this error from happening. So we'll instead run an init in
      # a single module first to create the buckets so that subsequent run-all commands do not fail.
      - name: "[Baseline]: Bootstrap child account with state & logs S3 buckets"
        if: ${{ contains(steps.bootstrap.outputs.terragrunt_command, 'plan') && steps.bootstrap.outputs.workflow == 'apply-new-account-baseline.yml' }}
        uses: gruntwork-io/pipelines-execute@v3.0.0
        with:
          token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
          tf_version: ${{ steps.bootstrap.outputs.terraform_version }}
          tg_version: ${{ steps.bootstrap.outputs.terragrunt_version }}
          pipelines_cli_version: ${{ steps.bootstrap.outputs.pipelines_cli_version }}
          working_directory: "${{ steps.bootstrap.outputs.working_directory }}/_global/account-baseline"
          terragrunt_command: "init"
          infra_live_repo: '.'
          infra_live_directory: '.'
          infra_live_repo_branch: ${{ steps.bootstrap.outputs.branch }}
          gruntwork_config: "${{ steps.bootstrap.outputs.gruntwork_config }}"

      - name: Authenticate to AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: us-east-1
          role-to-assume: "arn:aws:iam::${{ steps.bootstrap.outputs.account_id }}:role/${{ steps.bootstrap.outputs.role_name }}"
          role-duration-seconds: 3600
          role-session-name: ${{ steps.bootstrap.outputs.role_session_name }}

      # If we're doing a pipelines policy update, assume the role in the child account from the mgmt account
      - name: Authenticate to child AWS account
        if: ${{ steps.bootstrap.outputs.workflow == 'terragrunt-executor.yml' && steps.bootstrap.outputs.child_account_id != '' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: us-east-1
          role-to-assume: "arn:aws:iam::${{ steps.bootstrap.outputs.child_account_id }}:role/${{ steps.bootstrap.outputs.child_acct_role_name }}"
          role-duration-seconds: 3600
          role-session-name: ${{ steps.bootstrap.outputs.role_session_name }}
          role-chaining: true

      - name: Confirm Account Access
        if: steps.bootstrap.outputs.workflow == 'terragrunt-executor.yml'
        env:
          ACCOUNT: ${{ steps.bootstrap.outputs.account_id }}
          WORKING_DIRECTORY: ${{ steps.bootstrap.outputs.working_directory }}
        run: echo "::notice ::Running in account $ACCOUNT and planning in $WORKING_DIRECTORY"

      - name: Run terragrunt ${{ steps.bootstrap.outputs.terragrunt_command }} in ${{ steps.bootstrap.outputs.working_directory }}
        id: terragrunt
        uses: gruntwork-io/pipelines-execute@v3.0.0
        with:
          token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
          tf_version: ${{ steps.bootstrap.outputs.terraform_version }}
          tg_version: ${{ steps.bootstrap.outputs.terragrunt_version }}
          pipelines_cli_version: ${{ steps.bootstrap.outputs.pipelines_cli_version }}
          working_directory: ${{ steps.bootstrap.outputs.working_directory }}
          terragrunt_command: ${{ steps.bootstrap.outputs.terragrunt_command }}
          infra_live_repo: '.'
          infra_live_directory: '.'
          infra_live_repo_branch: ${{ steps.bootstrap.outputs.branch }}
          gruntwork_config: "${{ steps.bootstrap.outputs.gruntwork_config }}"


      - name: "[ProvisionAccount]: Setup access-control PR"
        id: provision_access_control
        if:  ${{ steps.bootstrap.outputs.workflow == 'create-account-and-generate-baselines.yml' }}
        uses: gruntwork-io-team/pipelines-setup-access-control@main
        with:
          new_account_name: ${{ steps.bootstrap.outputs.new_account_name }}

      - name: "[ProvisionAccount]: Read account request"
        id: account_request
        if:  ${{ steps.bootstrap.outputs.workflow == 'create-account-and-generate-baselines.yml' }}
        # Only try this if we've actually created the account
        env:
          NEW_ACCOUNT_NAME: ${{ steps.bootstrap.outputs.new_account_name }}
        run: |
          request_file_path="./_new-account-requests/account-$NEW_ACCOUNT_NAME.yml"

          org_name_prefix="$(yq -r ".org_name_prefix" "$request_file_path")"
          aws_region="$(yq -r ".aws_region" "$request_file_path")"
          requesting_team_name="$(yq -r ".requesting_team_name" "$request_file_path")"
          account_baseline_modules_version="$(yq -r ".account_baseline_modules_version" "$request_file_path")"
          account_baseline_cis_service_catalog_version="$(yq -r ".account_baseline_cis_service_catalog_version" "$request_file_path")"

          create_vpc="$(yq -r '.create_vpc' "$request_file_path")"

          # Handling edge case where account request file might not have a create_vpc field
          # We create one by default
          if [[ "$create_vpc" == "null" ]]; then
            create_vpc='true'
          fi

          echo "org_name_prefix=$org_name_prefix" >> "$GITHUB_OUTPUT"
          echo "aws_region=$aws_region" >> "$GITHUB_OUTPUT"
          echo "requesting_team_name=$requesting_team_name" >> "$GITHUB_OUTPUT"
          echo "account_baseline_modules_version=$account_baseline_modules_version" >> "$GITHUB_OUTPUT"
          echo "account_baseline_cis_service_catalog_version=$account_baseline_cis_service_catalog_version" >> "$GITHUB_OUTPUT"
          echo "create_vpc=$create_vpc" >> "$GITHUB_OUTPUT"

      - name: "[ProvisionAccount]: Get requesting PR number"
        id: get_pr_number
        if:  ${{ steps.bootstrap.outputs.workflow == 'create-account-and-generate-baselines.yml' && steps.bootstrap.outputs.terragrunt_command == 'apply' }}
        env:
          COMMIT_SHA: ${{ steps.bootstrap.outputs.branch }}
          GH_TOKEN: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
          REPO: ${{ github.repository }}
        run: |
          PR_NUMBER=$(gh -R "$REPO" pr list --search "$COMMIT_SHA" --state merged --json number -q '.[0].number')
          echo "The PR number is: $PR_NUMBER"
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

      - name: "[ProvisionAccount]: Check out terraform-aws-control-tower repo"
        if: ${{ steps.bootstrap.outputs.workflow == 'create-account-and-generate-baselines.yml' && steps.bootstrap.outputs.terragrunt_command == 'apply' }}
        uses: actions/checkout@v4
        with:
          repository: gruntwork-io/terraform-aws-control-tower
          token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
          path: terraform-aws-control-tower
          ref: ${{ env.CONTROL_TOWER_MODULES_VERSION }}

      - name: "[ProvisionAccount]: Install boilerplate"
        if:  ${{ steps.bootstrap.outputs.workflow == 'create-account-and-generate-baselines.yml' && steps.bootstrap.outputs.terragrunt_command == 'apply' }}
        shell: bash
        env:
          GITHUB_OAUTH_TOKEN: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
        run: |
          curl -Ls https://raw.githubusercontent.com/gruntwork-io/gruntwork-installer/main/bootstrap-gruntwork-installer.sh | bash /dev/stdin --version "$GRUNTWORK_INSTALLER_VERSION"
          gruntwork-install --binary-name boilerplate --repo https://github.com/gruntwork-io/boilerplate --tag "$BOILERPLATE_VERSION"

      - name: "[ProvisionAccount]: Run boilerplate to generate code"
        if:  ${{ steps.bootstrap.outputs.workflow == 'create-account-and-generate-baselines.yml' && steps.bootstrap.outputs.terragrunt_command == 'apply' }}
        shell: bash
        env:
          ACCOUNT_NAME: ${{ steps.bootstrap.outputs.new_account_name }}
          AWS_REGION: ${{ steps.account_request.outputs.aws_region }}
          ORG_NAME_PREFIX: ${{ steps.account_request.outputs.org_name_prefix }}
          ACCOUNT_BASELINE_MODULES_VERSION: ${{ steps.account_request.outputs.account_baseline_modules_version }}
          ACCOUNT_BASELINE_CIS_SERVICE_CATALOG_VERSION: ${{ steps.account_request.outputs.account_baseline_cis_service_catalog_version }}
          REQUESTING_TEAM_NAME: ${{ steps.account_request.outputs.requesting_team_name }}
          DEFAULT_TAGS: ${{ steps.bootstrap.outputs.default_tags }}
          CREATE_VPC: ${{ steps.account_request.outputs.create_vpc  }}
        run: |
          boilerplate \
            --template-url "./terraform-aws-control-tower//templates/landingzone/boilerplate-single-account-baseline" \
            --output-folder . \
            --var AccountName="$ACCOUNT_NAME" \
            --var AwsRegion="$AWS_REGION" \
            --var OrgNamePrefix="$ORG_NAME_PREFIX" \
            --var AccountBaselineModulesVersion="$ACCOUNT_BASELINE_MODULES_VERSION" \
            --var AccountBaselineCISServiceCatalogVersion="$ACCOUNT_BASELINE_CIS_SERVICE_CATALOG_VERSION" \
            --var RequestingTeamName="$REQUESTING_TEAM_NAME" \
            --var DefaultTags="$DEFAULT_TAGS" \
            --var CreateVPC="$CREATE_VPC" \
            --var VpcModuleVersion="$ACCOUNT_BASELINE_CIS_SERVICE_CATALOG_VERSION" \
            --non-interactive

      - name: "[ProvisionAccount]: Remove Control Tower Repo"
        if:  ${{ steps.bootstrap.outputs.workflow == 'create-account-and-generate-baselines.yml' && steps.bootstrap.outputs.terragrunt_command == 'apply' }}
        run: rm -rf terraform-aws-control-tower

      - name: "[ProvisionAccount]: Create Pull Request"
        if:  ${{ steps.bootstrap.outputs.workflow == 'create-account-and-generate-baselines.yml' && steps.bootstrap.outputs.terragrunt_command == 'apply' }}
        id: create_pr
        uses: peter-evans/create-pull-request@v6
        with:
          base: main
          token: ${{ secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
          branch: "enhancement/baseline-account-${{ steps.bootstrap.outputs.new_account_name }}"
          commit-message: "Generate account baseline for: ${{ steps.bootstrap.outputs.new_account_name }}"
          title: "Generate account baseline for: ${{ steps.bootstrap.outputs.new_account_name }}"
          body: |
            This pull request applies an account baseline to the **${{ steps.bootstrap.outputs.new_account_name }}** AWS account, which was created in https://github.com/${{ github.repository }}/pull/${{ steps.get_pr_number.outputs.pr_number }} using Gruntwork Landing Zone. To **apply** this baseline, do the following:

              1. Inspect the details in this pull request and confirm correctness.
              2. Merge this pull request.

            Once merged, Gruntwork Pipelines will `terragrunt apply` the baseline in the newly created AWS account.



      - name: "[ProvisionDelegatedAccount] Create new delegated repo"
        if: ${{ steps.bootstrap.outputs.workflow == 'provision-delegated-account.yml' && contains(steps.bootstrap.outputs.terragrunt_command , 'apply') }}
        env:
          GH_TOKEN: ${{secrets.MANAGE_REPOS_TOKEN }}
          GH_ORG: ${{github.repository_owner }}
          GH_DELEGATED_REPO_NAME: ${{ steps.bootstrap.outputs.delegate_repo_name }}
        run: |
          # Check if the repo exists before trying to create it
          GH_REPO_STATUS_CODE="$(curl --silent --write-out '%{http_code}' --output /dev/null \
            -X GET \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/$GH_ORG/$GH_DELEGATED_REPO_NAME")"

          # If the repo does not exist (404 status code), then create it
          if [[ "$GH_REPO_STATUS_CODE" == 404 ]]; then
            gh api \
              --method POST \
              -H "Accept: application/vnd.github.v3+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /orgs/$GH_ORG/repos \
              -f "name=$GH_DELEGATED_REPO_NAME" \
              -f visibility=private \
              -f auto_init=true

              echo "::notice title=New delegated repo created!::See created repository: https://github.com/$GH_ORG/$GH_DELEGATED_REPO_NAME."

          # If the repo exists (200 status code), print a message and continue
          elif [[ "$GH_REPO_STATUS_CODE" == 200 ]]; then
            echo "Repository https://github.com/$GH_ORG/$GH_DELEGATED_REPO_NAME already exists."

          # If GH returns a non 200 or non 404 status code, print and exit with an error
          else
            echo "Status code $GH_REPO_STATUS_CODE returned from GitHub API. Exiting with error."
            exit 1
          fi

      - name: "[ProvisionDelegatedAccount] Set new repo branch protection"
        if: ${{ steps.bootstrap.outputs.workflow == 'provision-delegated-account.yml' && contains(steps.bootstrap.outputs.terragrunt_command , 'apply') }}
        env:
          GH_TOKEN: ${{secrets.MANAGE_REPOS_TOKEN }}
          GH_ORG: ${{github.repository_owner }}
          GH_DELEGATED_REPO_NAME: ${{ steps.bootstrap.outputs.delegate_repo_name }}
        run: |
          echo "Setting branch protection rules for $GH_ORG/$GH_DELEGATED_REPO_NAME. See https://docs.gruntwork.io/pipelines/security/branch-protection for more information on recommended rules."
          curl -L \
            -X PUT \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/$GH_ORG/$GH_DELEGATED_REPO_NAME/branches/main/protection" \
            -d '{ "required_status_checks": { "strict": true, "checks": [ ] }, "required_pull_request_reviews": { "require_code_owner_reviews": true, "require_last_push_approval": true, "required_approving_review_count": 1 }, "enforce_admins": false, "restrictions": null }'

      - name: "[ProvisionDelegatedAccount] Assign ci-user as repo collaborator"
        if: ${{ steps.bootstrap.outputs.workflow == 'provision-delegated-account.yml' && contains(steps.bootstrap.outputs.terragrunt_command , 'apply') }}
        env:
          GH_TOKEN: ${{secrets.MANAGE_REPOS_TOKEN }}
          GH_ORG: ${{github.repository_owner }}
          GH_DELEGATED_REPO_NAME: ${{ steps.bootstrap.outputs.delegate_repo_name }}
          GH_CI_RO_USER: ${{env.GITHUB_CI_READONLY_USER }}
        run: |
          echo "Add CI Read Only User as Read-Only Collaborator on the new repo."
          gh api \
            --method PUT \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/$GH_ORG/$GH_DELEGATED_REPO_NAME/collaborators/$GH_CI_RO_USER" \
            -f permission='read'

      - name: "[ProvisionDelegatedAccount] Checkout new delegated repo"
        if: ${{ steps.bootstrap.outputs.workflow == 'provision-delegated-account.yml' && contains(steps.bootstrap.outputs.terragrunt_command , 'apply') }}
        uses: actions/checkout@v4
        with:
          token: ${{secrets.MANAGE_REPOS_TOKEN }}
          repository: ${{github.repository_owner }}/${{ steps.bootstrap.outputs.delegate_repo_name }}
          path: ${{ steps.bootstrap.outputs.delegate_repo_name }}
          ref: main
          fetch-depth: 0

      - name: "[ProvisionDelegatedAccount] Install boilerplate"
        if: ${{ steps.bootstrap.outputs.workflow == 'provision-delegated-account.yml' && contains(steps.bootstrap.outputs.terragrunt_command , 'apply') }}
        shell: bash
        run: |
          curl -Ls https://raw.githubusercontent.com/gruntwork-io/gruntwork-installer/main/bootstrap-gruntwork-installer.sh | bash /dev/stdin --version "$GRUNTWORK_INSTALLER_VERSION"
          gruntwork-install --binary-name boilerplate --repo https://github.com/gruntwork-io/boilerplate --tag "$BOILERPLATE_VERSION"

      - name: "[ProvisionDelegatedAccount] Checkout architecture catalog"
        if: ${{ steps.bootstrap.outputs.workflow == 'provision-delegated-account.yml' && contains(steps.bootstrap.outputs.terragrunt_command , 'apply') }}
        uses: actions/checkout@v4
        with:
          token: ${{secrets.GRUNTWORK_CODE_ACCESS_TOKEN }}
          repository: gruntwork-io/terraform-aws-architecture-catalog
          path: terraform-aws-architecture-catalog
          ref: ${{env.ARCH_CATALOG_VERSION }}

      - name: "[ProvisionDelegatedAccount] Run boilerplate to scaffold new delegated repo"
        if: ${{ steps.bootstrap.outputs.workflow == 'provision-delegated-account.yml' && contains(steps.bootstrap.outputs.terragrunt_command , 'apply') }}
        shell: bash
        working-directory: ${{ steps.bootstrap.outputs.delegate_repo_name }}
        env:
          TAGS: ${{ steps.bootstrap.outputs.tags }}
          WORKING_DIRECTORY: ${{ steps.bootstrap.outputs.working_directory }}
          INFRA_LIVE_DIRECTORY: ${{ steps.bootstrap.outputs.infra_live_directory }}
          ORG_NAME_PREFIX: ${{ steps.bootstrap.outputs.org_name_prefix }}
          AWS_REGION: ${{ steps.bootstrap.outputs.aws_region }}
          INFRA_LIVE_REPO_NAME: ${{ steps.bootstrap.outputs.terragrunt_version.delegate_repo_name }}
          TERRAFORM_VERSION: ${{ steps.bootstrap.outputs.s.terraform_version }}
          TERRAGRUNT_VERSION: ${{ steps.bootstrap.outputs.terragrunt_version }}
          CREATE_VPC: ${{ steps.bootstrap.outputs.create_vpc }}
          CATALOG_REPOSITORIES: ${{ steps.bootstrap.outputs.catalog_repositories }}
        run: |
          # Convert list of accounts to Bash array. We use working_directory here because GW Pipelines will configure
          # its name as a comma-separated list of account names.
          IFS=',' read -ra account_names <<<"$WORKING_DIRECTORY"

          # Convert Bash array to JSON array: https://stackoverflow.com/a/67489301/483528
          account_names_as_json_list="$(jq --compact-output --raw-output --monochrome-output --null-input '$ARGS.positional' --args -- "${account_names[@]}")"

          # Use yq to filter accounts.yml to just the accounts we created, producing JSON output
          AWS_ACCOUNTS="$(yq --no-colors -o=json -I=0 pick\("$account_names_as_json_list"\) "../$INFRA_LIVE_DIRECTORY/accounts.yml")"

          # Run boilerplate to scaffold out the delegated infra-live repo contents
          boilerplate \
            --template-url ../terraform-aws-architecture-catalog//templates/devops-foundations-infrastructure-live-delegated \
            --output-folder . \
            --var AWSAccounts="$AWS_ACCOUNTS" \
            --var OrgNamePrefix="$ORG_NAME_PREFIX" \
            --var DefaultRegion="$AWS_REGION" \
            --var RepoBaseUrl=github.com/{{ .GithubOrg }} \
            --var GithubOrg={{ .GithubOrg }} \
            --var InfraLiveRepoName="$INFRA_LIVE_REPO_NAME" \
            --var InfraModulesRepoName="$INFRA_MODULES_REPO_NAME" \
            --var InfraModulesReleaseVersion="$INFRA_MODULES_RELEASE_VERSION" \
            --var TerraformVersion="$TERRAFORM_VERSION" \
            --var TerragruntVersion="$TERRAGRUNT_VERSION" \
            --var DefaultTags="$TAGS" \
            --var VPCCreated="$CREATE_VPC" \
            --var CatalogRepositories="$CATALOG_REPOSITORIES" \
            --non-interactive

      - name: "[ProvisionDelegatedAccount] Create Pull Request in new delegated repo with scaffolding"
        if: ${{ steps.bootstrap.outputs.workflow == 'provision-delegated-account.yml' && contains(steps.bootstrap.outputs.terragrunt_command , 'apply') }}
        id: create_scaffolding_pr
        uses: peter-evans/create-pull-request@v6
        with:
          base: main
          path: ${{ steps.bootstrap.outputs.delegate_repo_name }}
          token: ${{secrets.MANAGE_REPOS_TOKEN }}
          branch: "bootstrap-repository"
          commit-message: "Bootstrap infrastructure-live repository"
          title: "Bootstrap infrastructure-live repository"
          body: |
            This pull request adds all code required to set up your `infrastructure-live` repository.

      - name: "[ProvisionDelegatedAccount] Show Pull Request URL in Summary"
        if: ${{ steps.bootstrap.outputs.workflow == 'provision-delegated-account.yml' && contains(steps.bootstrap.outputs.terragrunt_command , 'apply') }}
        env:
          PR_URL: ${{steps.create_scaffolding_pr.outputs.pull-request-url }}
          DELEGATED_REPO_NAME: ${{ steps.bootstrap.outputs.delegate_repo_name }}
        run: |
          echo "### Successfully bootstrapped $DELEGATED_REPO_NAME! ðŸš€" >> "$GITHUB_STEP_SUMMARY"
          echo "[Link to Pull Request]($PR_URL)" >> "$GITHUB_STEP_SUMMARY"


    outputs:
      account_id: ${{ matrix.jobs.AccountId }}
      branch: ${{ steps.bootstrap.outputs.branch }}
      workflow: ${{ steps.bootstrap.outputs.workflow }}
      working_directory: ${{ steps.bootstrap.outputs.working_directory }}
      terragrunt_command: ${{ steps.bootstrap.outputs.terragrunt_command }}
      additional_data: ${{ steps.bootstrap.outputs.additional_data }}
      child_account_id: ${{ steps.bootstrap.outputs.child_account_id }}
      new_account_name: ${{ steps.bootstrap.outputs.new_account_name }}
      team_account_names: ${{ steps.bootstrap.outputs.team_account_names }}
